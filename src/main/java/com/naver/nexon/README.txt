문제

어떤 자연수 n이 있을 때, d(n)을 n의 각 자릿수 숫자들과 n 자신을 더한 숫자라고 정의하자.

예를 들어

d(91) = 9 + 1 + 91 = 101   (식.1)
이 때, n을 d(n)의 제네레이터(generator)라고 한다. 위의 예에서 91은 101의 제네레이터이다.

어떤 숫자들은 하나 이상의 제네레이터를 가지고 있는데, 101의 제네레이터는 91 뿐 아니라 100도 있다. 그런데 반대로, 제네레이터가 없는 숫자들도 있으며, 이런 숫자를 인도의 수학자 Kaprekar가 셀프 넘버(self-number)라 이름 붙였다. 예를 들어 1,3,5,7,9,20,31 은 셀프 넘버 들이다.

1 이상이고 5000 보다 작은 모든 셀프 넘버들의 합을 구하라.

설명

해결

문제를 해결하는 방법으로 여러가지가 있는데 그 중 큰 틀에서 두가지정도의 방법이 나와 두가지 공유해드리겠습니다.

solution1
이 방법은 아래의 두가지 성질을 이용한 방법입니다.
1. SelfNumber의 집합과 Generator를 가진 수들의 집합의 교집합은 공집합이다.
2. Generator는 항상 자기 자신보다 작다.

1번 성질은 SelfNumber의 정의가 Generator가 없는 수이므로 참입니다.
2번 성질은 식.1에 따라 어떤 자연수 x가 존재할 때 d(x)는 항상 x보다 크기때문에 참입니다.

따라서 이 두 성질을 이용하여 범위내 모든 자연수에 식.1을 적용하여 나온 수를 index로하여 배열에 체크를 해두는 방법으로 SelfNumber를 찾을 수 있습니다.

solution2
이 방법은 가장 간단하게 생각해볼 수 있는 방법으로 범위를 돌면서 범위내 모든 숫자가 SelfNumber인지 판단하는 방법입니다.
이 방법의 핵심은 SelfNumber가 나오는 규칙을 발견하지 못했기 때문에 SelfNumber인지 판단을 할때 많은 비용이 소모됐고 따라서 비용을 줄여가는 방법으로 생각해봤습니다.

모든 수에 대해서 해볼 수는 없기 때문에 일단 범위를 줄여야 합니다.

첫번째 범위를 줄이는 방법은 solution1의 두번째 성질에 의하여 자기 자신보다 작은수에서만 식1에 대입했을때 자신이 나올 수 있어서 범위를 1 ~ 자기자신으로 줄였습니다.

두번째 범위를 줄이는 방법은 어떤 숫자의 각 자릿수에는 0 ~ 9라는 숫자만 올 수 있습니다. 따라서 자릿수 * 9 를 SelfNumber인지 확인할 수에 빼게 되면 최소 범위를 찾을 수 있습니다.
여기서 조금만 더 나가면 맨 앞자리수는 그 숫자만큼만 커질 수 있으므로 그 숫자를 사용하면 됩니다.
Ex) 459라는 수가 SelfNumber인지 찾을때
백의자리 : 4
십의자리 : 9
일의자리 : 9

459-22 = 427 부터 자신의 제너레이터가 될 수 있다고 판단하는것입니다.

이렇게 위와 아래의 범위를 줄여 그 범위내 숫자들을 식.1에 대입하고 SelfNumber인지 확인할 수랑 같다면 이 수는 SelfNumber가 아니게 됩니다.